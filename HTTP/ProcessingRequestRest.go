package HTTP

import (
	"encoding/json"
	"fmt"
)

/*
Чтобы было удобно сериализовать и десериализовать данные в какой-либо формат, в Go придумали...

Структурные теги:
	Структурный тег — небольшое сообщение, через которое к полю структуры можно добавить дополнительную информацию.
	Часто структурные теги используются для указания преобразования полей структуры в другие форматы данных, такие как JSON, YAML, XML и другие,
	Однако, структурные теги могут также служить для хранения любой другой метаинформации, которая может быть полезна в других пакетах или для внутреннего использования в коде.


	Компилятор Go не проверяет формат описания структурных тегов. Какого-либо стандарта здесь нет, поэтому нужно руководствоваться только правилами, принятыми в сообществе Go:
		Набор структурных тегов указывают после типа поля в структуре и заключают в грависы ``.
		Теги разделяются пробелами.
		Имя тега и его значение разделяют двоеточием без пробелов.
		Значение тега заключают в кавычки, а если значений несколько, то их разделяют запятой.
		Имя тега и его значение пишут в формате snake_case или CamelCase (например, в JSON принято использовать snake_case формат).
*/

type ExampleUser struct {
	ID        string `yaml:"Id"`
	Name      string `json:"name,omitempty"` //omitempty - если значение пустое (zero value) — поле не попадёт в json вообще.
	Password  string `json:"-"`              // - поле в любом случае игнорируется и не передаётся в json
	Email     string `json:"email" yaml:"Еmail"`
	CreatedAt int    `json:"created_at" yaml:"createdАt"`
}

/*

user := ExampleUser{
	ID: "a1",
	Name: "Василий",
	Email: "example@email.com",
	CreatedAt: 14102023,
}

конвертация данной структуры в JSON

{
	"ID": "a1",
	"name": "Василий",
	"email": "example@email.com",
	"created_at": 14102023
}

*/

func JsonFuncs() {

	//json.Valid  bool - проверяет на валидность

	validJSON := []byte(`{"name": "Alice", "age": 30}`)
	invalidJSON := []byte(`{"name": "Bob", "age": }`)

	if json.Valid(validJSON) {
		fmt.Println("Valid first JSON")
	} else {
		fmt.Println("Invalid first JSON")
	}

	if json.Valid(invalidJSON) {
		fmt.Println("Valid second JSON")
	} else {
		fmt.Println("Invalid second JSON")
	}

	//json.Marshal(any) - конвертация в json
	//json.MarshalIndent(any) - конвертация в json, приводит результат обработки данных к привычному виду, разбивает на строки, добавляет префикс и отступ к каждому ключу:
	//json.Unmarshal(data []byte ,any) - из данныx в JSON-формате, в указатель на переменную
	//json.Encoder - записывает JSON в поток (файл, сеть, HTTP-ответ и т. д.)
	//json.Decoder - читает JSON из потока (файл, HTTP-запрос и т. д.)

	/*

		| Сравнение            | Marshal / Unmarshal                | Encoder / Decoder                     |
		| -------------------- | ---------------------------------- | ------------------------------------- |
		| Работает с           | байтами / строками                 | потоками (`io.Reader` / `io.Writer`)  |
		| Использование памяти | всё загружается сразу              | можно обрабатывать потоково           |
		| Используется где     | при работе со структурами, тестами | при HTTP, файлах, сетевых соединениях |
		| Возврат              | `[]byte` и `error`                 | пишет/читает напрямую (возврата нет)  |


	*/
}
