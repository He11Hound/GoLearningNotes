package main

import (
	"fmt"
	"go/format"
	"os"
	"strings"
)

func main() {
	// Создаём пустую мапу (словарь), где ключ и значение — строки.
	//Здесь будут храниться пары ключ=значение, переданные из аргументов командной строки.

	values := make(map[string]string) //Строковая мапа

	// Проверяем, что количество аргументов после имени программы — чётное.
	//Т.к. ожидаем ввод вида: KEY1 VALUE1 KEY2 VALUE2 ...
	if (len(os.Args)-1)%2 != 0 {
		panic("bad args")
	}

	// Цикл по аргументам командной строки, начиная с 1 (т.к. 0 — это имя программы).
	//Идём с шагом 2, чтобы брать пары аргументов: ключ и значение.

	for i := 1; i < len(os.Args); i += 2 {
		values[os.Args[i]] = os.Args[i+1]
	}

	// Создаём strings.Builder — эффективный способ собирать большую строку по частям.
	var sb strings.Builder

	// Пишем в builder заголовок генерируемого файла.
	//Это стандартный комментарий, который отмечает, что файл сгенерирован автоматически

	fmt.Fprintf(&sb, "%s", `
	// Code generated by go generate; DO NOT EDIT.
	//This file was generated by genconstants.go

	package Generations

	const (
	`)

	// Перебираем все пары из мапы values.
	//Для каждой пары создаём строку вида: KEY = "VALUE"
	for k, v := range values {
		fmt.Fprintf(&sb, "%s = %q\n", k, v)
	}

	// Закрываем блок const.
	fmt.Fprintf(&sb, ")")

	//Преобразуем builder в []byte. для работы с go/format
	generated := []byte(sb.String())

	// Форматируем полученный код по стандартам Go (как gofmt делает).
	formatted, err := format.Source(generated)
	if err != nil {
		panic(err)
	}

	// Записываем сгенерированный код в файл const.go с правами 0644.
	err = os.WriteFile("Generations/const.go", formatted, 0644)
	if err != nil {
		panic(err)
	}
}
