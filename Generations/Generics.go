package Generations

import (
	"fmt"
	"golang.org/x/exp/constraints"
)

/*
Дженерики
Дженерики — это обобщённые типы и методы в программировании, которые позволяют создавать более гибкий и переиспользуемый код.
Они позволяют разработчикам писать код, который работает с разными типами данных, не указывая конкретные типы заранее.
*/

//Предположим, что у вас есть слайс []int32. Нужно написать функцию для поиска в нём максимального числа. Вроде всё просто:

func MaxInt32(slice []int32) int32 {
	if len(slice) == 0 {
		// для пустого слайса возвращаем нулевое значение
		return 0
	}

	maxValue := slice[0]

	for i := 1; i < len(slice); i++ {
		if slice[i] > maxValue {
			maxValue = slice[i]
		}
	}

	return maxValue
}

//Теперь представьте, что в какой-то момент понадобилось написать аналогичную функцию для слайса []int64. Так как Go — строго типизированный язык, существующую функцию использовать нельзя.
//Потом потребуется реализовать поиск для []float32 и других слайсов
//Так как тело функций одинаковое, возникнет желание реализовать единственную функцию, которая будет находить максимальное значение в слайсах любых числовых типов.
//Для решения подобных проблем и существуют дженерики (generics)

//Чтобы реализовать это, вы напишете функцию, которая объявляет параметры типа в дополнение к обычным параметрам функции. Эти параметры типа делают функцию универсальной, позволяя ей работать с аргументами разных типов. Вы будете вызывать функцию с аргументами типа и обычными аргументами функции.

func MaxNumber[T constraints.Integer | constraints.Float](slice []T) T { //Принимает любой слайс целых чисел и чисел с плавающей точкой
	if len(slice) == 0 {
		// для пустого слайса возвращаем нулевое значение
		return 0
	}
	maxValue := slice[0]
	for i := 1; i < len(slice); i++ {
		if slice[i] > maxValue {
			maxValue = slice[i]
		}
	}

	return maxValue
}

func ExamplePrintMaxNumber() {
	fmt.Println("Max int32", MaxNumber([]int32{45, 678, -232, 0, 2}))
	fmt.Println("Max int64", MaxNumber([]int64{-2435, 243434, -5655, -1, 777}))
	fmt.Println("Max float32", MaxNumber([]float32{-1.56, 17, 6.78, 1024.782}))
}

/*
Зачем нужны дженерики
Чаще всего дженерики бывают полезны при работе со слайсами и мапами. Многие алгоритмы не зависят от типов элементов:
	пересечение, объединение множеств;
	поиск максимального или минимального значения;
	получение среднего или стандартного отклонения;
	вызов функции преобразования для каждого элемента слайса или мапы (map);
	удаление элементов в соответствии с результатом логической функции (filter);
	получение агрегирующего значения для всех элементов (reduce).

constraints - предоставляет интерфейсы, но можно самому написать
	Complex — комплексные числа ~complex64 | ~complex128;
	Float — числа с плавающей точкой ~float32 | ~float64;
	Integer — целые числа Signed | Unsigned;
	Ordered — типы, которые поддерживают операции сравнения Integer | Float | ~string.
	Signed — знаковые целые числа ~int | ~int8 | ~int16 | ~int32 | ~int64;
*/

type Number interface {
	int | float64
}

// Универсальная функция для сложения двух чисел
func Add[Type Number](val1, val2 Type) Type {
	return val1 + val2
}

//Если вместо интерфейса передать any, то будет принимать абсолютно любой тип перменной
//	fmt.Println как раз реализует такое

// С помощью дженериков можно создавать не только универсальные функции, но и универсальные типы.
// Vector — имя для слайса элементов любого типа.
// Важно, чтобы элементы были одинаковы.
type Vector[T any] []T

//type VectorInt Vector[int]

// Можно использовать параметризацию типов и при описании структур:
type Tree[T any] struct { //Тип T - любой тип
	Value    T          //поле, содержащее значение типа T
	Children []*Tree[T] //срез указателей на другие узлы того же типа, то есть на дочерние элементы (детей) дерева.
}

var ti = Tree[int]{
	Value: 10,
	Children: []*Tree[int]{
		{Value: 20},
	}}
var ts = Tree[string]{
	Value: "alex",
	Children: []*Tree[string]{
		{Value: "mike"},
		{Value: "alice"},
	}}

//С появлением дженериков интерфейс может предъявлять требования не только к набору методов, но и к типу данных.
