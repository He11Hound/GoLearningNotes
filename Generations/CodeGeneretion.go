package Generations

import (
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"
)

/*
Процесс, когда программа пишет исходный код другой программы, называют кодогенерацией или метапрограммированием.

Go — идейный наследник C, попытка разработчиков обновить язык и избавиться от пережитков. Препроцессор C, как и многих других языков программирования, позволяет генерировать код из макросов. Архитекторы Go отказались от препроцессора. Они посчитали концепцию макросов устаревшей, запутанной, недостаточно гибкой, затрудняющей восприятие и поддержку кода.

Команда go generate, в отличие от препроцессора, не вызывается автоматически при компиляции пакета, поэтому её нужно запускать самостоятельно.
Она просканирует все файлы текущей директории и запустит операции, указанные в комментариях //go:generate.


Кодогенерация с помощью go generate используется в следующих случаях:
	Protobuf: генерация Go-кода из .proto-файлов деклараций;
	SQL: генерация методов для работы с моделью;
	HTML: внедрение .html-файлов в Go-исходники;
	преобразование бинарных файлов, например JPEG, в []byte;
	генерация частных реализаций из обобщённой модели.

Команда go generate не делает анализ зависимостей и, соответственно, может отрабатывать на невалидном коде. Но программа прекращает работу, если одна из команд в директивах завершилась с ошибкой.
*/

func SimpleExample() {
	// Создаём пустую мапу (словарь), где ключ и значение — строки.
	//Здесь будут храниться пары ключ=значение, переданные из аргументов командной строки.

	values := make(map[string]string) //Строковая мапа

	// Проверяем, что количество аргументов после имени программы — чётное.
	//Т.к. ожидаем ввод вида: KEY1 VALUE1 KEY2 VALUE2 ...
	if (len(os.Args)-1)%2 != 0 {
		panic("bad args")
	}

	// Цикл по аргументам командной строки, начиная с 1 (т.к. 0 — это имя программы).
	//Идём с шагом 2, чтобы брать пары аргументов: ключ и значение.

	for i := 1; i < len(os.Args); i += 2 {
		values[os.Args[i]] = os.Args[i+1]
	}

	// Создаём strings.Builder — эффективный способ собирать большую строку по частям.
	var sb strings.Builder

	// Пишем в builder заголовок генерируемого файла.
	//Это стандартный комментарий, который отмечает, что файл сгенерирован автоматически

	fmt.Fprintf(&sb, "%s", `
	// Code generated by go generate; DO NOT EDIT.
	//This file was generated by genconstants.go

	package Generations

	const (
	`)

	// Перебираем все пары из мапы values.
	//Для каждой пары создаём строку вида: KEY = "VALUE"
	for k, v := range values {
		fmt.Fprintf(&sb, "%s = %q\n", k, v)
	}

	// Закрываем блок const.
	fmt.Fprintf(&sb, ")")

	//Преобразуем builder в []byte. для работы с go/format
	generated := []byte(sb.String())

	// Форматируем полученный код по стандартам Go (как gofmt делает).
	formatted, err := format.Source(generated)
	if err != nil {
		panic(err)
	}

	// Записываем сгенерированный код в файл const.go с правами 0644.
	err = os.WriteFile("Generations/const.go", formatted, 0644)
	if err != nil {
		panic(err)
	}
}

/*
Пакет text/template реализует шаблоны с подстановкой аргументов и несложной программируемой логикой. Он позволяет генерировать из шаблонов любой текст, в том числе исходный код.

Используемый шаблон, как правило, привязывается к определенной структуре данных (например, struct), данные из которой будут появляться внутри шаблона.
Любой шаблон может состоять из трех видов базовых сущностей, заключенных в фигурные скобки {{ }} .

Действия (Actions)
Это фрагменты текста, заключенные в фигурные скобки {{ }}, в которых выполняется вычисление или подстановка некоторых данных. Именно за счет них текст внутри шаблона по своему наполнению становится динамическим.
Действиями можно считать как простую подстановку переменной, так и выполнение циклов или функций, который формируют итоговый текст. Все они непосредственно управляют тем, как будет выглядеть окончательный результат.
Условия (Conditions)
К условиям относятся классические конструкции if-else, которые используются непосредственно внутри шаблона. Благодаря условиям можно добавлять или убирать из конечного вывода целые текстовые блоки, что существенно увеличивает возможности шаблонизации и гибкость генерации контента.
Циклы (Loops)
Внутри шаблона можно выполнять классические циклы, выводя множество однотипных блоков, но с разной ключевой информацией.

Создание, парсинг, выполнение
Для создания, парсинга и выполнения шаблонов используются следующие функции:
New(). Создает новый шаблон, который впоследствии нужно будет определить.
Parse(). Анализирует переданную строку, содержащую текст шаблона, после чего возвращает уже готовый к использованию шаблон.
PrseFiles() используется для обработки целых файлов с шаблоном.
Execute(). Выполняет готовый шаблон (который прошел этап парсинга), применяя к нему указанную структуру данных, после чего записывает результат в заданную переменную.
*/

type Person struct {
	Name string
	Age  int
}

func TemplateExample() {
	alicePerson := Person{"Алиса", 23}
	aliceTemplate := "Это {{ .Name }} и ей {{ .Age }} года." // стоит заметить что указывается параметры через .

	// создаем новый шаблон и парсим его содержимое, тем самым подготавливая его к дальнейшему использованию
	readyTemplate, err := template.New("example").Parse(aliceTemplate)

	if err != nil {
		fmt.Println("Ошибка при создании шаблона")
		return
	}

	// выполняем шаблон и выводим его стандартный поток
	err = readyTemplate.Execute(os.Stdout, alicePerson) //os.Stdout - консоль

	if err != nil {
		fmt.Println("Ошибка при выполнении шаблона")
		return
	}
}

/*
Другие пакеты, связанные с кодогенерацией

gomock — генерация моков, удовлетворяющих интерфейсам, для упрощения процедуры тестирования;
protobuf — генерация структур и методов из .proto-деклараций межъязыкового протокола обмена данными Protocol Buffers модели gRPC;
go-swagger — генерация клиента и сервера REST API из спецификаций Swagger;
easyjson — генерация кода кодирования/декодирования JSON, который работает быстрее интроспекции encoding/json;
go-queryset — генерация методов для составления SQL-запросов;
reform — Object–Relational Mapping, генерация SQL-модели и методов доступа из языковой структуры данных с помощью go generate.
*/
