package net

import (
	"context"
	"time"
)

/*
	Интерфейс Listener

	type Listener interface {
		Accept() (Conn, error)
		Close() error
		Addr() Addr
	}

	Listener представляет сетевой слушатель, который принимает входящие
	соединения. Это базовый интерфейс для всех сетевых слушателей в Go.
	Используется для создания серверов, которые принимают соединения от клиентов.

	Основные методы:

	func Accept() (Conn, error)
		- Принимает входящее соединение
		- Блокирующая операция до получения соединения
		- Возвращает Conn для обмена данными с клиентом
		- err: ошибка если принятие соединения не удалось
		- Должен вызываться в цикле для принятия множественных соединений

	func Close() error
		- Закрывает слушатель
		- Прекращает принятие новых соединений
		- Освобождает ресурсы слушателя
		- err: ошибка если закрытие не удалось
		- Существующие соединения остаются открытыми

	func Addr() Addr
		- Возвращает адрес слушателя
		- Возвращает адрес, на котором слушает сервер
		- Полезно для логирования и отладки
		- Используется для идентификации слушателя

	Типы слушателей:

	TCPListener - TCP слушатель
		- Принимает TCP соединения
		- Используется для большинства интернет-серверов
		- Поддерживает как IPv4, так и IPv6
		- Надежные потоковые соединения

	UnixListener - Unix сокет слушатель
		- Принимает Unix сокет соединения
		- Используется для межпроцессного взаимодействия
		- Быстрее чем TCP для локальных соединений
		- Работает только на локальной машине

	Особенности работы:
	- Listener является интерфейсом, реализуемым различными типами слушателей
	- Accept() блокируется до получения соединения
	- Слушатель должен быть закрыт после использования
	- Принятые соединения обрабатываются независимо
	- Один слушатель может принимать множественные соединения

	Примеры использования:

	// TCP сервер
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()

	fmt.Printf("Сервер слушает на %s\n", listener.Addr())

	// Принятие соединений
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Ошибка принятия соединения: %v\n", err)
			continue
		}

		// Обработка соединения в горутине
		go handleConnection(conn)
	}

	// Unix сокет сервер
	listener, err := net.Listen("unix", "/tmp/socket")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()

	// Принятие соединений с таймаутом
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Ошибка принятия соединения: %v\n", err)
			continue
		}

		go handleUnixConnection(conn)
	}

	// Сервер с ограничением времени
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()

	// Принятие соединений с контекстом
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			fmt.Println("Время работы сервера истекло")
			return
		default:
			conn, err := listener.Accept()
			if err != nil {
				log.Printf("Ошибка принятия соединения: %v\n", err)
				continue
			}

			go handleConnection(conn)
		}
	}

	// Сервер с обработкой ошибок
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()

	for {
		conn, err := listener.Accept()
		if err != nil {
			// Проверка типа ошибки
			if netErr, ok := err.(net.Error); ok {
				if netErr.Temporary() {
					log.Printf("Временная ошибка: %v\n", err)
					continue
				}
			}
			log.Printf("Критическая ошибка: %v\n", err)
			break
		}

		go handleConnection(conn)
	}

	// Сервер с логированием
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()

	fmt.Printf("Сервер запущен на %s\n", listener.Addr())

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Ошибка принятия соединения: %v\n", err)
			continue
		}

		// Логирование соединения
		fmt.Printf("Принято соединение от %s\n", conn.RemoteAddr())

		go handleConnection(conn)
	}

	// Сервер с ограничением соединений
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()

	maxConnections := 100
	activeConnections := 0
	connectionSemaphore := make(chan struct{}, maxConnections)

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Ошибка принятия соединения: %v\n", err)
			continue
		}

		// Проверка лимита соединений
		select {
		case connectionSemaphore <- struct{}{}:
			activeConnections++
			go func(conn net.Conn) {
				defer func() {
					conn.Close()
					<-connectionSemaphore
					activeConnections--
				}()
				handleConnection(conn)
			}(conn)
		default:
			// Отклонение соединения при превышении лимита
			conn.Close()
			fmt.Printf("Отклонено соединение (лимит: %d)\n", maxConnections)
		}
	}

	=== РЕАЛИЗАЦИИ ИНТЕРФЕЙСА ===

	TCPListener:
		- Реализует TCP слушатель
		- Принимает TCP соединения
		- Поддерживает все методы Listener интерфейса
		- Дополнительные методы для TCP специфичных операций

	UnixListener:
		- Реализует Unix сокет слушатель
		- Принимает Unix сокет соединения
		- Поддерживает все методы Listener интерфейса
		- Дополнительные методы для Unix сокет специфичных операций

	=== ОБРАБОТКА ОШИБОК ===

	1. Ошибки Accept():
		- net.Error: сетевая ошибка
		- net.Error.Temporary(): временная ошибка
		- os.ErrClosed: слушатель закрыт

	2. Ошибки Close():
		- net.Error: сетевая ошибка
		- os.ErrClosed: слушатель уже закрыт

	3. Ошибки Addr():
		- Обычно не возвращает ошибок
		- Может вернуть nil если слушатель не инициализирован

	=== ПРОИЗВОДИТЕЛЬНОСТЬ ===

	1. Множественные соединения:
		- Используйте горутины для обработки соединений
		- Параллельная обработка увеличивает производительность
		- Ограничивайте количество одновременных соединений

	2. Буферизация:
		- Используйте буферизованные каналы для управления соединениями
		- Предотвращает переполнение памяти
		- Позволяет контролировать нагрузку

	3. Таймауты:
		- Устанавливайте таймауты для операций
		- Предотвращает зависание сервера
		- Позволяет контролировать время выполнения

	=== БЕЗОПАСНОСТЬ ===

	1. Валидация соединений:
		- Проверяйте адреса клиентов
		- Ограничивайте количество соединений
		- Используйте аутентификацию

	2. Обработка ошибок:
		- Всегда обрабатывайте ошибки
		- Логируйте ошибки для отладки
		- Не передавайте ошибки клиентам

	3. Ресурсы:
		- Ограничивайте использование ресурсов
		- Мониторьте количество соединений
		- Используйте пулы ресурсов

	=== МОНИТОРИНГ ===

	1. Статистика соединений:
		- Считайте количество активных соединений
		- Мониторьте время обработки соединений
		- Отслеживайте ошибки соединений

	2. Логирование:
		- Логируйте все входящие соединения
		- Записывайте ошибки в лог
		- Используйте структурированное логирование

	3. Метрики:
		- Измеряйте производительность сервера
		- Отслеживайте использование ресурсов
		- Анализируйте паттерны трафика
*/
