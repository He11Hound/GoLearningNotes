package io

/*
	ИНТЕРФЕЙС READER

	type Reader interface {
		Read([]byte) (int, error)
	}

	Reader - это базовый интерфейс для чтения данных из потока.
	Это один из самых важных интерфейсов в Go, так как он определяет
	стандартный способ чтения данных из различных источников.

	Основной метод:

	Read([]byte) (int, error)
		- Читает данные в предоставленный буфер
		- Возвращает количество прочитанных байтов и ошибку
		- n может быть меньше len(p) даже если ошибки нет
		- Возвращает io.EOF когда достигнут конец потока
		- Может возвращать другие ошибки для различных проблем

	Поведение:
	- Read должен блокировать до тех пор, пока не прочитает хотя бы один байт
	- Read может прочитать меньше байтов чем размер буфера
	- Read должен возвращать io.EOF когда достигнут конец потока
	- Read не должен изменять буфер кроме записи данных

	Примеры реализации:
	- os.File (файлы)
	- bytes.Reader (байты в памяти)
	- strings.Reader (строки)
	- net.Conn (сетевые соединения)
	- bufio.Reader (буферизованное чтение)

	Примеры использования:

	// Чтение из файла
	file, err := os.Open("data.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	buffer := make([]byte, 1024)
	n, err := file.Read(buffer)
	if err != nil && err != io.EOF {
		log.Fatal(err)
	}
	fmt.Printf("Прочитано %d байтов: %s\n", n, string(buffer[:n]))

	// Чтение из строки
	reader := strings.NewReader("Hello, World!")
	buffer := make([]byte, 5)
	n, err := reader.Read(buffer)
	fmt.Printf("Прочитано: %s\n", string(buffer[:n]))

	// Чтение всех данных
	data, err := io.ReadAll(reader)
	fmt.Printf("Все данные: %s\n", string(data))

	Особенности работы:
	- Reader может быть использован только один раз
	- После достижения EOF, последующие вызовы Read должны возвращать EOF
	- Reader не обязан быть потокобезопасным
	- Размер буфера влияет на производительность

	Связь с другими интерфейсами:
	- ReaderAt - для чтения с определенной позиции
	- ReadCloser - для Reader с методом Close
	- ReadSeeker - для Reader с возможностью изменения позиции
	- ReadWriter - для Reader который также может записывать

	Лучшие практики:
	- Всегда проверяйте ошибки после Read
	- Используйте io.ReadAll для чтения всех данных
	- Используйте io.Copy для копирования данных
	- Учитывайте размер буфера для производительности
	- Обрабатывайте io.EOF как нормальное завершение
*/
