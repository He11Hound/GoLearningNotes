package main

//todo: Изучить типы данных SQL (INT, VARCHAR, DATE, BOOLEAN, TEXT, DECIMAL и т.д.)
//todo: Ограничения (Constraints): PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT
//todo: Операции с NULL (IS NULL / IS NOT NULL)
//todo: Подзапросы (Subqueries): в WHERE, FROM и SELECT
//todo: Объединение запросов (UNION / UNION ALL / INTERSECT / EXCEPT)
//todo: GROUP BY и агрегатные функции (SUM, AVG, MAX, MIN, COUNT)
//todo: HAVING — фильтрация после группировки
//todo: JOIN — INNER, LEFT, RIGHT, FULL, CROSS
//todo: Вложенные JOIN’ы и алиасы таблиц
//todo: Хранимые процедуры (Stored Procedures) и функции
//todo: Триггеры (Triggers): автоматическое выполнение при изменении данных
//todo: Последовательности (SEQUENCE) и автоинкрементные поля
//todo: Блокировки и уровни изоляции транзакций (READ COMMITTED, REPEATABLE READ, SERIALIZABLE)
//todo: Оптимизация запросов и индексов, анализ с помощью EXPLAIN / EXPLAIN ANALYZE
//todo: Временные таблицы (TEMP / TEMPORARY TABLE)
//todo: Работа с датами и временем (NOW(), DATE_ADD(), DATE_DIFF(), FORMAT и т.д.)
//todo: Работа со строками (CONCAT, SUBSTRING, UPPER, LOWER, REPLACE, TRIM)
//todo: Работа с JSON (JSON_EXTRACT, JSON_OBJECT, JSON_ARRAY, JSONB в PostgreSQL)
//todo: Создание, изменение и удаление таблиц (CREATE / ALTER / DROP TABLE)
//todo: Резервное копирование и восстановление (BACKUP / RESTORE / pg_dump / mysqldump)
//todo: Права доступа и пользователи (GRANT / REVOKE / CREATE USER)
//todo: Работа с внешними ключами и каскадными операциями (ON DELETE CASCADE / ON UPDATE CASCADE)
//todo: Блокировки

//Крткий справочник, шпаргалка SQL:
//	Тут я опускаю но во всех sql командах на конце должен быть ;
//	Ключевые слова можно писать в нижнем регистре, но мне привычно в верхнем
//
//	CRUD операции:
//		Выборка данных (R):
//			Конструкции:
//			SELECT - Выбор данных из бд
//			DISTINCT - Возвращает все уникальные записи
//			* - в выборку попадают все поля (Пример 1)
//			AS - Алиасы, используются для более удобного восприятия полей, выходящих из запроса (Пример 3)
//			WHERE - Блок условий
//				Операторы
//				=, <, >, <=, >=, != (Пример 4)
//				AND - логичское и (Пример 5)
//				OR - логичское или (Пример 6)
//				IN и NOT IN - для фильтрации по нескольким значениям (Пример 7)
//				LIKE - для поиска по подстрокам (Пример 8)
//				BETWEEN ... AND - для поиска по подстрокам (Пример 9)
//			ORDER BY - задаёт (Пример 10)
//				ASC - по возрастанию
//				DESC - по убыванию
//			LIMIT - ограничение показанных данных (Пример 11) , Через запись вида LIMIT 10,100 - можно устанвливать и LIMIT и OFFSET, первое значение - сммещение, второе - лимит
//			COUNT(*) - количество записей в полученной выборке (Пример 12)
//			OFFSET - Пропускает определённое количество записей в результате (Смещение) (Пример 13)
//
//
//			Примеры:
//				(1) SELECT * FROM table - вернуть все строки по всем полям из таблицы table
//				(2) SELECT field1, field2 FROM table - вернуть все строки по полям field1, field2 из таблицы table
//				(3) SELECT field1 AS "цена", field2 AS "кол-во товара" FROM table - вернуть все строки по полям field1, field2 из таблицы table, в результирующей таблице на месте field1, field2 будет "цена" и "кол-во товара" соответсвенно
//				(4) SELECT * FROM table WHERE field1 > 100 - вернуть все строки по всем полям из таблицы table, где значение поле field1 больше 100
//				(5) SELECT * FROM table WHERE field1 > 100 AND field2 < 10 - вернуть все строки по всем полям из таблицы table, где значение поле field1 больше 100 И field < 10
//				(6) SELECT * FROM table WHERE field1 > 100 OR field2 < 10 - вернуть все строки по всем полям из таблицы table, где значение поле field1 больше 100 ИЛИ field < 10
//				(7) SELECT * FROM table WHERE category IN ('electronics', 'books') - вернуть все строки по всем полям из таблицы table, где значения поле category равны 'electronics', 'books'
//				(8) SELECT * FROM table WHERE client_name LIKE '%Даниил%' - вернуть все строки по всем полям из таблицы table, где в значение поля client_name есть совпадение по 'Данил'
//				(9) SELECT * FROM table WHERE client_name BETWEEN 'Борис' AND 'Дмитрий' - вернуть все строки по всем полям из таблицы table, где значения полей client_name между Борис и Дмитрий
//				(10) SELECT * FROM table ORDER BY id DESC - вернуть все строки по всем полям из таблицы table, сортируя по id в обратном порядке
//				(11) SELECT * FROM table LIMIT 10 - вернуть все 10 строк по всем полям из таблицы table
//				(12) SELECT COUNT(*) FROM table WHERE field1 > 100 - вернуть количество записей, где field1 больше 100
//				(12) SELECT * FROM table OFFSET 10 -  вернуть все строки, кроме первых 10 по всем полям из таблицы table
//
//		Добавление данных (С, U)
//			Конструкции:
//				INSERT INTO ... VALUES - Добавляет новую запись в таблицу (Пример 1)
//				UPDATE ... SET - Обновляет записи (Пример 2)
//			В начале указывается имя таблицы, затем в круглых скобках перечисляются имена колонок, для которых будут определены значения. А после ключевого слова VALUES определяются значения добавляемой записи. Количество столбцов и значений добавляемой строки должно совпадать.
//
//			Примеры:
//				(1) INSERT INTO tablename (field1, field2 ...) VALUES (value1,value2 ...) - Вставить в таблицу tablename для полей field1, field2 и т.д значения value1, value2 и т.д
//				Для добавления нескольких записей, можно через запятую указывать несколько (value1,value2 ...)
//				(2) UPDATE tablename SET price = 1.2 * price - Обновляет все записи в таблице tablename, увеличивает значение price в 1.2 раза
//
//		Удаление данных (D)
//			Конструкции:
//				DELETE - удаляет запись (Пример 1)
//
//			Примеры:
//				(1) DELETE * FROM tablename - Удаляет все записи из таблицы tablename РАВНОСИЛЬНО DELETE FROM tablename
//
//
//	Индексы:
//		В упрощённом виде индексы можно рассматривать как дополнительную таблицу, у которой каждая запись состоит из двух значений: значение из таблицы, по которому происходит сортировка, и сам индекс — специальный идентификатор, определяющий соответствующую этому значению строку. Находим значение в индексе — получаем строку в таблице. Чтобы поиск и выборки с использованием индекса работали корректно, СУБД следит за тем, чтобы всегда были проиндексированы все записи.
//		Наличие индекса помогает не только при поиске конкретного значения, но и при выборке значений в каком-то диапазоне. Например, делается выборка WHERE id > 100 AND id < 150. С индексом по полю id достаточно получить крайние значения (100 и 150) в индексе и взять все записи, которые находятся между ними.
//
//		Создание индекса:
//			CREATE INDEX indexname ON tablename (column list)
//				indexname — уникальное имя для индекса
//				tablename — имя таблицы, для которой создаётся индекс
//				column list — один или несколько столбцов через запятую, значения которых будут использоваться для индексации
//
//
//		Для хранения индексов требуется дополнительное место на диске и в оперативной памяти. Чем длиннее значение (ключ), по которому происходит индексация, и чем больше записей в таблице, тем больше места нужно для хранения индекса.
//		При добавлении и удалении строк, а также при изменении индексируемых столбцов, требуется перестроить индексы таблицы. Это обновление индексов замедляет скорость выполнения операций по изменению таблицы.
//
//		Удаление индекса:
//			DROP INDEX indexname
//
//	Транзакции:
//		Транзакция — это набор последовательных запросов к БД, который представляет собой одну неделимую операцию с данными. Транзакция либо выполняется полностью без ошибок, либо не выполняется вовсе.
//
//		Основные команды:
//			BEGIN (START TRANSACTION) - указывает на начало транзакции. Результаты следующих запросов не будут вносится сразу в базу, а будут накапливаться.
//			COMMIT - записывает в базу все изменения, которые были сделаны в рамках транзакции.
//			ROLLBACK - отменяет транзакцию. При этом база данных останется в состоянии, какое она имела до начала транзакции.
//
//		Пример:
//			START TRANSACTION;
//
//			-- Снимаем 100 с баланса пользователя с id = 1
//			UPDATE accounts
//			SET balance = balance - 100
//			WHERE id = 1;
//
//			-- Добавляем 100 пользователю с id = 2
//			UPDATE accounts
//			SET balance = balance + 100
//			WHERE id = 2;
//
//			-- Проверяем, что баланс не ушёл в минус
//			-- (в некоторых СУБД можно сделать проверку через код приложения)
//
//			-- Если всё хорошо — фиксируем изменения
//			COMMIT;
//
//			-- Если возникла ошибка — откатываем
//			ROLLBACK;
